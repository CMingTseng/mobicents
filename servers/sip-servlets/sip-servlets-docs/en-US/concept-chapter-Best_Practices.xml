<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="bp-Best_Practices">
  <title>Best Practices</title>

  <section>
    <title>Mobicents Sip Servlets Performance Tips</title>

    <para>JBoss</para>

    <para>You can look at the following wiki page: JBossASTuning. Most of the
    things there don't apply, but it's always good to have a fast AS. The most
    important thing is to remove logs, leaving just what's strictly needed.
    Check your log config file in
    $JBOSS_HOME/server/default/conf/jboss-log4j.xml</para>

    <para>SIP </para>

    <para>properties for the SIP stack. </para>

    <para>gov.nist.javax.sip.THREAD_POOL_SIZE Default value: 64 This thread
    pool is responsible for parsing SIP messages, from socket messages into
    objects. A small value will make the stack less responsive, since new
    messages have to wait in a queue for free threads. In UDP, this can lead
    to more retransmissions. Big pool sizes allocate resources that you don't
    really need. The default value can look a little exaggerated, but please
    take a look at the next point. </para>

    <para>gov.nist.javax.sip.REENTRANT_LISTENER Default value: true This flag
    indicates if the SIP stack listener (in this case its the SIP RA itself)
    is executed by one only thread, or concurrently by the threads that parse
    the messages. Since the code in the SIP RA has been changed to support
    concurrency, there is really no reason to change this property. This
    properties can be override in resources/sipra/sipra.entity.properties
    </para>

    <para>JVM </para>

    <para>These notes depend on the JVM used, but should be pretty much
    standard. These where written with Sun JDK 1.6 in mind, but should apply
    to &gt;= JDK 1.5 as well. To pass arguments to the JVM change
    $JBOSS_HOME/bin/run.conf or $JBOSS_HOME/bin/run.bat, depending on your
    operating system. Garbage Collection JVM ergonomics try to select the best
    garbage collector for you. The default behaviour is to select the
    throughput collector. The problem of the throughput collector is that have
    long pauses times, that block the processing of the JVM. If you don't
    expect so much load, you can try to use the incremental, low pause,
    garbage collector (-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode). SIP
    apllications can bennefit a lot from it, since it reduces the among of
    retransmissions. For more information please read: Garbage Collector
    Tuning Heap Size Heap size is important because of garbage collection.
    Having a very big heap can stop you JVM for seconds, to perform garbage
    collection. Small heap sizes are not desired either, because puts a lot
    off pressure in garbage collection. For more information please read:
    Performance Wite Papper </para>

    <para>Operating System </para>

    <para>These notes are for RHEL, but should apply to other versions of
    unix. Large Memory Pages To know more about large memory pages, and how to
    set them, please visit: Java Support for Large Memory Pages Setting large
    memories pages reduces CPU utilization by 5%. Please make sure you pass
    the option -XX:+UseLargePages and you don't get "Java HotSpot(TM) Server
    VM warning: Failed to reserve shared memory (errno = 22)" when starting
    JBoss. For more information check the presentation given by Andrig Mille
    on JBoss World: Performance Tuning JBoss Enterprise Application Platform
    on Linux Network buffers You can increase the network buffers size by
    ading the follwing lines to your /etc/sysctl.conf file: net.core.rmem_max
    = 16777216 net.core.wmem_max = 16777216 net.ipv4.tcp_rmem = 4096 87380
    16777216 net.ipv4.tcp_wmem = 4096 65536 16777216 Then restart. You should
    see improvements in I/O. With SIP, the performance improvement is about
    20%. Again, you'll probably don't need it unless you have a very high
    load.</para>
  </section>

  <section>
    <title>NAT Traversal</title>

    <para>Also STUN is not generally considered a viable solution for
    enterprises because STUN cannot be used with symmetric NATs. and in many
    situations most enterprise-grade firewalls are symmetric and it requires
    STUN support in the SIP Client Today most of the proxy/media gateway in
    place at VoIP providers now recognize the public IP address the packets
    has been received from and in the case where both SIP end points are
    behind a NAT they can act as gateways so they can deal with clients behind
    NAT. I tried this with Mobicents on my home network behind a NAT by using
    the shopping demo to call my cell phone and it worked flawlessly without
    STUN. With regard to TURN now, TURN is an IETF standard, which implements
    media relay for SIP end-points. TURN (Traversal Using Relay NAT) solves
    the problems of clients behind symmetric NATs which cannot rely on STUN to
    solve NAT traversal. TURN connects clients behind a NAT to a single peer
    to provide the same protection as that created by symmetric NATs and
    firewalls. The TURN server acts as a relay, any data received is
    forwarded. The approach however is not ideal. It assumes the clients have
    a trust relationship with a TURN server and request session allocation
    based on shared credentials. This has scalability issues, requires complex
    changes in the SIP clients, as TURN protocol is difficult to implement,
    has no possibility of distributing the load and complicates the
    configuration of the SIP user agent. Then there is ICE (Interactive
    Connection Establishment), which leverages both STUN and TURN (and other
    methods ?) to solve the NAT traversal issues. It allows devices to probe
    for multiple paths of communication by trying to use different port
    numbers and STUN techniques. If ICE support is present in both devices,
    there is a good chance the devices can start communication end-to-end
    without any intermediary media relay. Depending on the NAT type, the
    communication might not be able to take place even if by using ICE, in
    this case a media relay must be used. ICE isn't really widespread yet and
    doesn't seem to take off and the ICE capability has to be implemented in
    the SIP devices which is not the case for most of them. Also depending on
    the connection negotiated it may often require a reINVITE adding more load
    to the SIP network and more latency to the call. Also If the initiating
    ICE client attempts to call a non-ICE client then the call setup-process
    will revert to a conventional SIP call requiring NAT traversal to be
    solved by other means. Another approach that requires no changes in the
    SIP devices, is to reuse the trust relationship the SIP device already has
    with the SIP Proxy. In contrast with how TURN works, the SIP Proxy and not
    the User agent does the session reservation for the media relay. This has
    the immediate advantage that the SIP UA does not have to have any TURN
    capability built in and secondary a database with user credentials does
    not need to be stored on both the TURN server and the client. Another
    advantage is the fact that the SIP Proxy has always more clues about where
    is the best place to assign a media relay for a SIP session than the SIP
    devices themselves. This allows per call allocation of a media relay
    session in an optimum place on the Internet and solves the load balancing
    and scalability of the media relay function. So remember that Mobicents is
    on the server side so this shouldn't impact us at all, but in some cases
    our applications need to act as a SIP UAC or UAS(announcement, IVR apps),
    in real deployments where we do need support for NAT traversal</para>
  </section>
</chapter>
