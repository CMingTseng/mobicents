package org.mobicents.slee.examples.callforwardblock;

import java.text.ParseException;
import java.util.Iterator;
import java.util.Map;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sip.InvalidArgumentException;
import javax.sip.ServerTransaction;
import javax.sip.SipException;
import javax.sip.SipProvider;
import javax.sip.SipStack;
import javax.sip.address.Address;
import javax.sip.address.AddressFactory;
import javax.sip.address.URI;
import javax.sip.header.ContactHeader;
import javax.sip.header.HeaderFactory;
import javax.sip.header.ViaHeader;
import javax.sip.message.MessageFactory;
import javax.sip.message.Request;
import javax.sip.message.Response;
import javax.slee.ActivityContextInterface;
import javax.slee.ChildRelation;
import javax.slee.RolledBackContext;
import javax.slee.Sbb;
import javax.slee.SbbContext;
import javax.slee.SbbLocalObject;
import javax.slee.facilities.ActivityContextNamingFacility;
import javax.slee.nullactivity.NullActivityContextInterfaceFactory;
import javax.slee.nullactivity.NullActivityFactory;

import org.apache.log4j.Logger;
import org.mobicents.slee.resource.sip.SipActivityContextInterfaceFactory;
import org.mobicents.slee.resource.sip.SipFactoryProvider;
import org.mobicents.slee.services.sip.common.SipSendErrorResponseException;
import org.mobicents.slee.services.sip.registrar.LocationService;
import org.mobicents.slee.services.sip.registrar.LocationServiceException;
import org.mobicents.slee.services.sip.registrar.RegistrationBinding;

/**
 * Base SBB class
 * @author hchin
 */
public abstract class BaseSbb implements Sbb {
	protected SbbContext sbbContext; // This SBB's SbbContext
	protected MessageFactory msgFactory;
	protected AddressFactory addrFactory;
	protected HeaderFactory hdrFactory;
	protected SipProvider sipProvider;
	protected SipActivityContextInterfaceFactory activityContextInterfaceFactory;
	protected NullActivityContextInterfaceFactory nullACIFactory;
	protected NullActivityFactory nullActivityFactory;
	protected ActivityContextNamingFacility acNamingFacility;

	protected static final String JNDI_ENV_PATH = "java:comp/env";
	protected static final String JNDI_SIPFACTORYPROVIDER_PATH = "slee/resources/jainsip/1.1/provider";
	protected static final String SIP_ACI_FACTORY_PATH = "slee/resources/jainsip/1.1/acifactory";
	protected static final String JNDI_NULL_ACI_FACTORY = "slee/nullactivity/activitycontextinterfacefactory";
	protected static final String JNDI_NULL_ACTIVITY_FACTORY = "slee/nullactivity/factory";
	protected static final String JNDI_ACTIVITY_CONTEXT_NAMING_FACILITY_NAME = "slee/facilities/activitycontextnaming";
	protected static final String CONTROLLER_ACTIVITY_CONTEXT_NAME = "CallControllerActivityContext";
	protected static final String JNDI_PROFILE_FACILITY_NAME = "slee/facilities/profile";

	private static Logger log = Logger.getLogger(BaseSbb.class);

	public void setSbbContext(SbbContext context) {
		this.sbbContext = context;
		log.info("setSbbContext called");
		Context ctxt = null;
		try {
			ctxt = (Context)new InitialContext().lookup(JNDI_ENV_PATH);
			SipFactoryProvider factoryProvider = (SipFactoryProvider)ctxt.lookup(JNDI_SIPFACTORYPROVIDER_PATH);
			addrFactory = factoryProvider.getAddressFactory();
			hdrFactory = factoryProvider.getHeaderFactory();
			msgFactory = factoryProvider.getMessageFactory();
			sipProvider = factoryProvider.getSipProvider();
			activityContextInterfaceFactory = (SipActivityContextInterfaceFactory) ctxt
				.lookup(SIP_ACI_FACTORY_PATH);

			nullACIFactory = (NullActivityContextInterfaceFactory) ctxt.lookup(JNDI_NULL_ACI_FACTORY);
            nullActivityFactory = (NullActivityFactory) ctxt.lookup(JNDI_NULL_ACTIVITY_FACTORY);
            acNamingFacility = (ActivityContextNamingFacility) ctxt.lookup(JNDI_ACTIVITY_CONTEXT_NAMING_FACILITY_NAME);
		} catch (NamingException ne) {
			log.warn("Problem when executing setSbbContext", ne);
		}
	}
    public void unsetSbbContext() { 
    	this.sbbContext = null;
    }

    public void sbbCreate() throws javax.slee.CreateException {}
    public void sbbPostCreate() throws javax.slee.CreateException {}
    public void sbbActivate() {}
    public void sbbPassivate() {}
    public void sbbRemove() {}
    public void sbbLoad() {}
    public void sbbStore() {}
    public void sbbExceptionThrown(Exception exception, Object event, ActivityContextInterface activity) {
    	log.error("Exception generated by this SBB:", exception);
    	if (event != null)
    		log.info("Event parameter: " + event);
    	if (activity != null)
    		log.info("ActivityContextInterface parameter: " + activity);
    }
    public void sbbRolledBack(RolledBackContext context) {}
    protected final SbbLocalObject getSbbLocalObject() { return sbbContext.getSbbLocalObject(); }
	/**
	 * Convenience method to retrieve the SbbContext object stored in setSbbContext.
	 * 
	 * If your SBB doesn't require the SbbContext object you may remove this 
	 * method, the sbbContext variable and the variable assignment in setSbbContext().
	 *
	 * @return this SBB's SbbContext object
	 */
	protected SbbContext getSbbContext() {
		return sbbContext;
	}

    /**
     * Proxy request onto the appropriate child SBB
     * @param aci ActivityContextInterface
     * @param relation to child SBB
     * @return child SbbLocalObject
     */
	protected SbbLocalObject proxyEventToChildSbb(ActivityContextInterface aci,	ChildRelation relation) {
        SbbLocalObject child = null;
		try {
            if (relation.size() == 0)
            	child = relation.create();
            else {
            	log.info("Child relation size " + relation.size());
            	Iterator it = relation.iterator();
            	child = (SbbLocalObject)it.next();
            }
            
            // attach child to this activity
            aci.attach(child);
            
            // detach myself
//            aci.detach(getSbbLocalObject());
            
            // Event router will pass this event to child SBB
        } catch (Exception e) {
            log.warn("Exception proxying event to child SBB", e);
        }
        return child;
	}

    /**
     * Attempts to find a locally registered contact address for the given URI,
     * using the location service interface.
     * Copied from other Mobicents example applications
     */
    protected URI findLocalTarget(URI uri) throws SipSendErrorResponseException {
    	LocationService locationService = new LocationService();
    	String addressOfRecord = uri.toString();

        Map bindings = null;
        try {
            bindings = locationService.getBindings(addressOfRecord);
        } catch (LocationServiceException lse) {
            lse.printStackTrace();
            log.error("Error getting bindings for location service", lse);
        }

        if (bindings == null) {
            throw new SipSendErrorResponseException("User not found", Response.NOT_FOUND);
        }
        if (bindings.isEmpty()) {
            throw new SipSendErrorResponseException(
                    "User temporarily unavailable",
                    Response.TEMPORARILY_UNAVAILABLE);
        }

        Iterator it = bindings.values().iterator();
        URI target = null;
        while (it.hasNext()) {
            RegistrationBinding binding = (RegistrationBinding) it.next();
            log.debug("BINDINGS: " + binding);
            ContactHeader header = binding.getContactHeader(addrFactory, hdrFactory);
            log.debug("CONTACT HEADER: " + header);
            if (header == null) { // entry expired
                continue; // see if there are any more contacts...
            }
            Address na = header.getAddress();
            log.info("Found address: " + na);
            target = na.getURI();
            break;
        }
        if (target == null) {
            log.warn("findLocalTarget: No contacts for " + addressOfRecord + " found.");
            throw new SipSendErrorResponseException(
                    "User temporarily unavailable",
                    Response.TEMPORARILY_UNAVAILABLE);
        }
        return target;
    }

    /**
     * Remove Via Header from response.  If response is not meant for this server the send request
     * @param resp
     * @return TRUE send request, FALSE do not send
     */
    protected boolean removeViaHeader(Response resp) {
        Iterator viaHeaderIt = resp.getHeaders(ViaHeader.NAME);
        viaHeaderIt.next();
        viaHeaderIt.remove();
        if (!viaHeaderIt.hasNext())
            return false;
        else
        	return true;
    }

    /**
	 * Creates a new via header based on sip stack ip address and port
	 * @return ViaHeader
	 * @throws ParseException
	 * @throws InvalidArgumentException
	 */
	protected ViaHeader buildViaHeader() throws ParseException, InvalidArgumentException {
		SipStack sipStack = sipProvider.getSipStack();
		final String host = sipStack.getIPAddress();
		final int port = sipProvider.getListeningPoints()[0].getPort();
		final String transport = sipProvider.getListeningPoints()[0].getTransport();
		ViaHeader viaHeader = hdrFactory.createViaHeader(host, port, transport, null);
		return viaHeader;
	}
	
	protected void sendServerErrorResponse(ServerTransaction st, Request request, int respCode) {
		try {
			Response response = msgFactory.createResponse(respCode, request);
			st.sendResponse(response);
		} catch (SipException se) {
			log.error("Error sending response", se);
		} catch (ParseException pe) {
			log.error("Error sending response", pe);
		} catch (InvalidArgumentException iae) {
			log.error("Error invalid argument", iae);
		}
	}
	
}
