<?xml version='1.0'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<section
	id="section-MMS_Control_API">
	<title>MMS Control API</title>
	<para></para>
	<para>The main objective of the Media Server control API is to provide multimedia application developers with a Media Server abstraction interface.</para>
	<section
		id="section-Basic_Components_of_the_MMS_API">
		<title>Basic Components of the MMS API</title>
		<para>This section describes the basic objects of the API as well as some common design patterns.</para>
		<para>The API components consist of a related set of interfaces, classes, operations, events, capabilities, and exceptions. The API provides seven key objects common to media servers, and more advanced packages. We provide a very brief description of the API in this overview document; The seven key objects are:</para>
		<variablelist>
			<varlistentry>
				<term>MsProvider</term>
				<listitem>
					<para>Represents the “window” through which an application views the call processing.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>MsSession</literal>
				</term>
				<listitem>
					<para>Represents a call; this object is a dynamic “collection of physical and logical entities” that bring two or more endpoints together.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>MsEndpoint</term>
				<listitem>
					<para>Represents a logical endpoint (e.g., an announcement access server or an interactive voice response server).</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>MsConnection</literal>
				</term>
				<listitem>
					<para>Represents the dynamic relationship between an <literal>MsSession</literal> and a user agent.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>MsLink</term>
				<listitem>
					<para>Represent the dynamic relationship between two endpoints located on the same Media Server.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>MsSignalGenerator</term>
				<listitem>
					<para>Represents the media resource which is responsible for generating media.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>MsSignalDetector</term>
				<listitem>
					<para>Represents the media resource which is responsible for detecting media.</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>The purpose of an <literal>MsConnection</literal> object is to describe the relationship between an <literal>MsSession</literal> object and a user agent. An <literal>MsConnection</literal> object exists if the user agent is part of the media session. <literal>MsConnection</literal> objects are immutable in terms of their <literal>MsSession</literal> and user agent references. In other words, the <literal>MsSession</literal> and user agent object references do not change throughout the lifetime of the <literal>MsConnection</literal> object instance. The same <literal>MsConnection</literal> object may not be used in another <literal>MsSession</literal>.</para>
		<mediaobject
			id="mediaobj-sas-MMSControlAPI-dia-MsControlAPI.jpg">
			<imageobject>
				<imagedata
					align="center"
					width="400"
					fileref="images/sas-MMSControlAPI-dia-MsControlAPI.jpg"
					format="JPG" />
			</imageobject>
			<caption>
				<para>Interface Diagram of the MMS API</para>
			</caption>
		</mediaobject>
		<para>
			<literal>MsProvider</literal> can be used to create the <literal>MsSession</literal> object as well as the <literal>SignalGenerator</literal> and <literal>SignalDetector</literal> objects.</para>
		<para>
			<literal>
				<literal>MsSession</literal>
			</literal> is a transient association of (zero or more) connections for the purposes of engaging in a real-time communications interchange. The session and its associated connection objects describe the control and media flows taking place in a communication network. Applications create instances of an <literal>MsSession</literal> object with the <function>MsProvider.createSession()</function> method, which returns an <literal>MsSession</literal> object that has zero connections and is in the <literal>IDLE</literal> state. The MsProvider object instance does not change throughout the lifetime of the <literal>MsSession</literal> object. The MsProvider associated with an <literal>MsSession</literal> is obtained via the getProvider() method.</para>
		<para>Applications create instances of <literal>MsConnection</literal> objects with the <literal>MsSession</literal>
			<function>.createNetworkConnection(String endpointName)</function> method. The Application calls <literal>MsConnection</literal>
			<function>.modify(String localDesc, String remoteDesc)</function> passing the local <remark>TBD: what are these abbreviations?</remark>SDP and remote SDP. <literal>MsConnection</literal> at this time will find out the corresponding EndPoint, using JNDI, and using the <literal>endPointName</literal> passed to it. It will then call <function>createConnection(int mode)</function> to create an instance of Connection. This Connection creates the instance of <literal>RtpSocketAdaptorImpl</literal>, which opens up the socket for RTP data transfer. However, the transfer of data has not yet started.</para>
		<para>Applications create instances of <literal>MsLink</literal> object with the <literal>MsSession</literal>
			<function>.createLink(MsLinkMode mode)</function> method. The application calls <literal>MsLink</literal>
			<function>.join(String endpointName1, String endpointName2)</function>, passing the endpoint names of the two local endpoint to be joined. At this point, the <literal>MsLink</literal> object will find out the corresponding <literal>EndPoint</literal>s, using JNDI, and by using the <literal>endPointName</literal> passed to it. It will then call <function>createConnection(int mode)</function> to create an instance of the <literal>Connection</literal> object. This <literal>Connection</literal> creates the instance of <literal>RtpSocketAdaptorImpl</literal>, which opens up the socket for RTP data transfer. However, the transfer of data has not yet started. As soon as <literal>Connection</literal>s are created for both <literal>EndPoint</literal>s, <function>setOtherParty(Connection other)</function> is called on each <literal>Connection</literal> passing the other <literal>Connection</literal>, which starts the data transfer between the two <literal>Connection</literal>s.</para>
		<para>The application creates instances of <literal>MsSignalGenerator</literal> using <literal>MsProvider</literal>
			<function>.getSignalGenerator(endpointName)</function>, passing <literal>endPointName</literal>. The application calls <literal>MsGenerator</literal>
			<function>.apply(Announcement.PLAY, new String[] { Audio file URL })</function> to play the audio file. At this point <literal>MsGenerator</literal> looks up the <literal>EndPoint</literal> corresponding to the <literal>endpointName</literal> passed, and simply calls play on it to start the transmission of audio via RTP.</para>
	</section>
	<section
		id="section-Basic_API_Patterns_Listeners">
		<title>Basic API Patterns: Listeners</title>
		<para>The basic programming pattern of the API is that applications (which reside <quote>above</quote> the API) make synchronous calls to API methods. The platform or network element implementing the API can inform the application of underlying events (for example, the arrival of incoming calls) by means of Java events. The application provides <literal>Listener</literal> objects corresponding to the events it is interested in obtaining.</para>
		<variablelist>
			<title>
				<literal>Listeners</literal>
			</title>
			<varlistentry>
				<term>
					<literal>MsSessionListener</literal>
				</term>
				<listitem>
					<para>Applications which are interested in receiving events for changes in state of the <literal>MsSession</literal> object should implement <literal>MsSessionListener</literal>.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>MsConnectionListener</literal>
				</term>
				<listitem>
					<para>Applications which are interested in receiving events for changes of state in <literal>MsConnection</literal> should implement <literal>MsConnectionListener</literal>.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>MsLinkListener</literal>
				</term>
				<listitem>
					<para>Applications which are interested in receiving events for changes in state of MsLink should implement MsLinkListener.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>MsResourceListener</literal>
				</term>
				<listitem>
					<para>Applications interested in receiving events for changes in state of <literal>MsSignalDetector</literal> or <literal>MsSignalGenerator</literal> should implement <literal>MsResourceListener</literal>.</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	<section
		id="section-Events">
		<title>Events</title>
		<para>Each of the listeners defined above listen to different types of events fired by the API.</para>
		<formalpara>
			<title>Events related to <literal>MsSession</literal>
			</title>
			<para>
				<literal>MsSessionListener</literal> is listening for <literal>MsSessionEvent</literal>, which carries the <literal>MsSessionEventID</literal> representing an <literal>MsSession</literal> state change. The following table shows the different types of <literal>MsSessionEventID</literal>, when these events are fired, and the corresponding methods of <literal>MsSessionListener</literal> that will be called.</para>
		</formalpara>
		<informaltable
			id="informaltable-Events_Related_to_MsSession"
			frame="all">
			<tgroup
				cols="3"
				align="left"
				colsep="1"
				rowsep="1">
				<colspec
					colnum="1"
					colname="col1"/>
				<colspec
					colnum="2"
					colname="col2"/>
				<colspec
					colnum="3"
					colname="col3"/>
				<thead>
					<row>
						<entry>
							<literal>MsSessionEventID</literal>
						</entry>
						<entry>Description</entry>
						<entry>
							<literal>MsSessionListener</literal> Method Called</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>
							<literal>SESSION_CREATED</literal>
						</entry>
						<entry>Fired when <literal>MsProvider</literal>
							<function>.createSession()</function> is called and a new <literal>MsSession</literal> is created</entry>
						<entry>
							<function>public void sessionCreated(<literal>MsSessionEvent</literal> evt)</function>
						</entry>
					</row>
					<row>
						<entry>
							<literal>SESSION_CREATED</literal>
						</entry>
						<entry>Fired when <literal>MsProvider</literal>
							<function>.createSession()</function> is called and a new <literal>MsSession</literal>
        is created</entry>
						<entry>
							<function>public void sessionCreated(<literal>MsSessionEvent</literal> evt)</function>
						</entry>
					</row>
					<row>
						<entry>
							<literal>SESSION_ACTIVE</literal>
						</entry>
						<entry>When the <literal>MsConnection</literal> or <literal>MsLink</literal> is created on <literal>MsSession</literal> for the first time, it transitions to <literal>ACTIVE</literal> state and <literal>SESSION_ACTIVE</literal> is fired. After this the state remains <literal>ACTIVE</literal> even if the application creates more <literal>MsConnection</literal>s or <literal>MsLink</literal>s.</entry>
						<entry>
							<function>public void sessionActive(<literal>MsSessionEvent</literal> evt)</function>
						</entry>
					</row>
					<row>
						<entry>
							<literal>SESSION_INVALID</literal>
						</entry>
						<entry>When all the <literal>MsConnection</literal> or MsLink objects are disassociated from
        <literal>MsSession</literal>, it transitions to <literal>INVALID</literal> state and <literal>SESSION_INVALID</literal> is
        fired</entry>
						<entry>
							<function>public void sessionInvalid(<literal>MsSessionEvent</literal> evt)</function>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</informaltable>
		
		<formalpara>
			<title>Events Related to <literal>MsConnection</literal>
			</title>
			<para>
				<literal>MsConnectionListener</literal> listens for an <literal>MsConnectionEvent</literal>, which carries the <literal>MsConnectionEventID</literal> that represents an <literal>MsConnection</literal> state change. The following table shows the different types of <literal>MsConnectionEventID</literal>, when these events would be fired, and the corresponding methods of <literal>MsConnectionListener</literal> that will be called.</para>
		</formalpara>
		<informaltable
			id="informaltable-Events_Related_to_MsConnection"
			frame="all">
			<tgroup
				cols="3"
				align="left"
				colsep="1"
				rowsep="1">
				<colspec
					colnum="1"
					colname="col1"/>
				<colspec
					colnum="2"
					colname="col2"/>
				<colspec
					colnum="3"
					colname="col3"/>
				<thead>
					<row>
						<entry>
							<literal>MsConnectionEventID</literal>
						</entry>
						<entry>Description</entry>
						<entry>
							<literal>MsConnectionListener</literal> Method Called</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>
							<literal>CONNECTION_INITIALIZED</literal>
						</entry>
						<entry>As soon as new <literal>MsConnection</literal> is created by calling <literal>MsSession</literal>
							<function>.createNetworkConnection(String endpointName)</function>,  <literal>CONNECTION_INITIALIZED</literal> is fired.</entry>
						<entry>
							<function>public void connectionInitialized(<literal>MsConnection</literal>Event event)</function>
						</entry>
					</row>
					<row>
						<entry>
							<literal>CONNECTION_CREATED</literal>
						</entry>
						<entry>As soon as the RTP connection created by calling <literal>MsConnection</literal>
							<function>.modify(String localDesc, String remoteDesc)</function> is successful, <literal>CONNECTION_CREATED</literal> is fired. When <function>modify()</function> is called, <literal>MsConnection</literal> checks to see whether there is an endpoint associated with it and, if there is no endpoint, then this is creation of RTP connection request</entry>
						<entry>public void connectionCreated(<literal>MsConnection</literal>Event event)<remark>TBD: fix this last sentence: meaning unsure</remark>
						</entry>
					</row>
					<row>
						<entry>
							<literal>CONNECTION_MODIFIED</literal>
						</entry>
						<entry>As soon as <literal>MsConnection</literal> is successfully modified, by calling <literal>MsConnection</literal>
							<function>.modify(String localDesc, String remoteDesc)</function>, <literal>CONNECTION_MODIFIED</literal> is fired. When <function>modify()</function> is called, <literal>MsConnection</literal> checks to see whether there is an endpoint associated it and, if so, then this means it is a modification request.</entry>
						<entry>
							<function>public void connectionModifed(<literal>MsConnection</literal>Event event)</function>
						</entry>
					</row>
					<row>
						<entry>
							<literal>CONNECTION_DELETED</literal>
						</entry>
						<entry>As soon as <literal>MsConnection</literal> is successfully released,  (<literal>MsConnection</literal>
							<function>.release()</function>) <literal>CONNECTION_DELETED</literal> is fired.</entry>
						<entry>
							<function>public void connectionDeleted(<literal>MsConnection</literal>Event event)</function>
						</entry>
					</row>
					<row>
						<entry>
							<literal>@Deprecated TX_FAILED</literal>
						</entry>
						<entry>Whenever the creation of a new RTP connection or the modification of an existing <literal>MsConnection</literal> fails, <literal>TX_FAILED</literal> is fired.</entry>
						<entry>
							<function>public void txFailed(<literal>MsConnection</literal>Event event)</function>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</informaltable>
		<formalpara>
			<title>Events Related to <literal>MsLink</literal>
			</title>
			<para>
				<function>MsLinkListener</function> listens for an <literal>MsLinkEvent</literal> which carries the <literal>MsLinkEventID</literal> that represents an MsLink state change. The following table shows the different types of <literal>MsLinkEventID</literal>, when these events are fired, and the corresponding methods of <literal>MsLinkListener</literal> that are called.</para>
		</formalpara>
		<informaltable
			id="informaltable-Events_Related_to_MsLink"
			frame="all">
			<tgroup
				cols="3"
				align="left"
				colsep="1"
				rowsep="1">
				<colspec
					colnum="1"
					colname="col1"/>
				<colspec
					colnum="2"
					colname="col2"/>
				<colspec
					colnum="3"
					colname="col3"/>
				<thead>
					<row>
						<entry>
							<literal>MsLinkEventID</literal>
						</entry>
						<entry>Description</entry>
						<entry>
							<literal>MsLinkListener</literal> method called</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>
							<literal>LINK_CREATED</literal>
						</entry>
						<entry>As soon as a new <literal>MsLink</literal> is created by calling <literal>MsSession</literal>
							<function>.createLink(MsLinkMode mode)</function>, <literal>LINK_CREATED</literal> is fired.</entry>
						<entry>
							<function>public void linkCreated(MsLinkEvent evt)</function>
						</entry>
					</row>
					<row>
						<entry>
							<literal>LINK_JOINED</literal>
						</entry>
						<entry>Fired as soon as the <function>join(String a, String b)</function> operation of <literal>MsLink</literal> is successful.</entry>
						<entry>
							<function>public void linkJoined(MsLinkEvent evt)</function>
						</entry>
					</row>
					<row>
						<entry>
							<literal>LINK_DROPPED</literal>
						</entry>
						<entry>Fired as soon as the <function>release()</function> operation of <literal>MsLink</literal> is successful.</entry>
						<entry>
							<function>public void linkDropped(MsLinkEvent evt)</function>
						</entry>
					</row>
					<row>
						<entry>
							<literal>LINK_FAILED</literal>
						</entry>
						<entry>Fired as soon as the <function>join(String a, String b)</function> operation of <literal>MsLink</literal> fails.</entry>
						<entry>
							<function>public void linkFailed(MsLinkEvent evt)</function>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</informaltable>
	</section>
	<section
		id="section-MSC_API_Objects_Finite_State_Machines">
		<title>MSC API Objects: Finite State Machines</title>
		<formalpara>
			<title>
				<literal>MsSession</literal>State Finite State Machine</title>
			<para>The behavior of <literal>MsSession</literal> is specified in terms of Finite State Machines (<acronym>FSM</acronym>s) represented by <literal>MsSessionState</literal>, shown below:</para>
		</formalpara>
		<variablelist>
			<varlistentry>
				<term>
					<literal>IDLE</literal>
				</term>
				<listitem>
					<para>This state indicates that the session has zero connections or links.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>ACTIVE</literal>
				</term>
				<listitem>
					<para>This state indicates that the session has one or more connections or links.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>INVALID</literal>
				</term>
				<listitem>
					<para>This state indicates the session has lost all of its connections or links.</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<mediaobject
			id="mediaobj-sas-MMSControlAPI-dia-Session.jpg">
			<imageobject>
				<imagedata
					align="center"
					fileref="images/sas-MMSControlAPI-dia-Session.jpg"
					format="JPG" />
			</imageobject>
			<caption>
				<para></para>
			</caption>
		</mediaobject>
		<formalpara>
			<title>
				<literal>MsConnection</literal> Finite State Machine</title>
			<para>
				<literal>MsConnection</literal> state is represented by the <literal>MsConnectionState</literal> enum:</para>
		</formalpara>
		<variablelist>
			<varlistentry>
				<term>
					<literal>IDLE</literal>
				</term>
				<listitem>
					<para>This state indicates that the <literal>MsConnection</literal> has only been created and has no resources attached to it.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>HALF_OPEN</literal>
				</term>
				<listitem>
					<para>This state indicates that the <literal>MsConnection</literal> has created the RTP socket, but doesn't yet have any information about Remote SDP to send the RTP Packets. <literal>MsConnection</literal> is still usable in <literal>HALF_OPEN</literal> state if it is only receiving the RTP Packets but doesn't have to send any.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>OPEN</literal>
				</term>
				<listitem>
					<para>This state indicates that the <literal>MsConnection</literal> now has information about remote SDP and can send RTP Packates to the remote IP (for example, to a remote user agent).</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>FAILED</literal>
				</term>
				<listitem>
					<para>This state indicates that the creation or modification of <literal>MsConnection</literal> failed, and that the <literal>MsConnection</literal> object isn't reusable anymore.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>CLOSED</literal>
				</term>
				<listitem>
					<para>This state indicates that <literal>MsConnection</literal> has released all its resources and closed the RTP sockets. It is not usable any more.</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<formalpara>
			<title>
				<literal>MsLink</literal> Finite State Machine</title>
			<para>
				<literal>MsLink</literal> state is represented by the <literal>MsLinkState</literal> enum:</para>
		</formalpara>
		<variablelist>
			<varlistentry>
				<term>
					<literal>IDLE</literal>
				</term>
				<listitem>
					<para> This state indicates that the <literal>MsLink</literal> has been created and has no endpoints associated with it</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>JOINED</literal>
				</term>
				<listitem>
					<para> This state indicates that the connections from both endpoints have been created and that data transfer has started.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>FAILED</literal>
				</term>
				<listitem>
					<para> This state indicates that the creation of <literal>MsLink</literal> failed and is not usable anymore.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>
					<literal>INVALID</literal>
				</term>
				<listitem>
					<para>This state indicates that <literal>MsLink</literal> has closed the connections of both endpoints and is not usable anymore.</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	<section
		id="section-API_Methods_and_Usage">
		<title>API Methods and Usage</title>
		<para>So far we have specified the key objects as well as their Finite State Machines (<acronym>FSM</acronym>s). To understand operationally how these objects are used and the methods they provide, we can look at the UML sequence diagram examples. The following call flow depicts a simple announcement.</para>
		<mediaobject
			id="mediaobj-sas-MMSControlAPI-dia-IVRMsConnectionAPI.jpg">
			<imageobject>
				<imagedata
					align="center"
					width="700"
					fileref="images/sas-MMSControlAPI-dia-IVRMsConnectionAPI.jpg"
					format="JPG" />
			</imageobject>
			<!--<caption>
				<para></para>
			</caption>-->
		</mediaobject>
		<remark>TBD: Replace this orderedlist with a callout list once the graphic is remade.</remark>
		<orderedlist>
			<listitem>
				<para>The application receives an underlying signaling message.</para>
			</listitem>
			<listitem>
				<para>The application registers listeners.</para>
			</listitem>
			<listitem>
				<para>The application registers listeners.</para>
			</listitem>
			<listitem>
				<para>The application registers listeners.</para>
			</listitem>
			<listitem>
				<para>The application creates an <literal>MsSession</literal> object.</para>
			</listitem>
			<listitem>
				<para>The application creates an <literal>MsConnection</literal> object using the <literal>MsSession</literal> object.</para>
			</listitem>
			<listitem>
				<para>The application modifies <literal>MsConnection</literal>, passing the SDP descriptor received on the signaling channel.</para>
			</listitem>
			<listitem>
				<para>
					The <literal>MsConnection</literal> implementation sends a request to the media server using one of the control protocols.</para>
			</listitem>
			<listitem>
				<para>The server responds that the media server connection has been created.</para>
			</listitem>
			<listitem>
				<para>The application receives <literal>ConnectionEvent.CONNECTION_CREATED</literal>.</para>
			</listitem>
			<listitem>
				<para>The application obtains the server's SDP and sends a response to the user agent. Media conversation has started.</para>
			</listitem>
			<listitem>
				<para>The application creates a <literal>SignalGenerator</literal> object and asks it to play an announcement.</para>
			</listitem>
			<listitem>
				<para>The application creates a <literal>SignalGenerator</literal> object and asks it to play an announcement.</para>
			</listitem>
			<listitem>
				<para>The application creates a <literal>SignalGenerator</literal> and asks it to play the announcement.</para>
			</listitem>
			<listitem>
				<para>The server reports that the announcement is complete.</para>
			</listitem>
			<listitem>
				<para>The server reports that the announcement is complete.</para>
			</listitem>
		</orderedlist>
		<example
			id="example-Example_Code">
			<title>Example Code</title>
<programlisting
				id="proglist-Example_Code"
				linenumbering="numbered"
				role="Java"><![CDATA[
package org.mobicents.mscontrol;

import org.mobicents.media.msc.common.MsLinkMode;
import org.mobicents.media.server.impl.common.events.EventID;
import org.mobicents.mscontrol.impl.MsProviderImpl;

/**
 * This is just a psuedocode to show how to use the MSC Api. This example uses
 * the Packet Relay Endpoint and Announcement Endpoint as follows
 *
 * user agent <----> RTP Connection <---- (one side) Packet Relay Endpoint (other side) <-----> MsLink  <----> Announcement Endpoint
 *
 * @author amit bhayani
 *
 */
public class MyMSCTest implements <literal>MsSessionListener</literal>, <literal>MsConnection</literal>Listener, MsLinkListener {

    private <literal>MsSession</literal> session;
    private MsProvider msProvider;

    public void startMedia() {

        // Creating the provider
        MsProvider provider = new MsProviderImpl();

        // Registering the Listeners
        provider.addSessionListener(this);
        provider.addConnectionListener(this);
        provider.addLinkListener(this);

        // Creating the Session
        session = provider.createSession();

        // Creating the connection passing the Endpoint Name. Here we are
        // creating Packet Relay Endpoint which has only two connections. One is
        // connected to user agent and other we can connect to Announcement Endpoint
        <literal>MsConnection</literal> connection = session.createNetworkConnection("media/trunk/PacketRelay/$");

        // Get the Remote SDP here and pass it to connection. If creation of
        // connection is successful connectionCreated method will be called
        connection.modify("$", remoteDesc);
    }

    public void sessionActive(<literal>MsSessionEvent</literal> evt) {

    }

    public void sessionCreated(<literal>MsSessionEvent</literal> evt) {

    }

    public void sessionInvalid(<literal>MsSessionEvent</literal> evt) {

    }

    public void connectionCreated(<literal>MsConnection</literal>Event event) {

        // Since the Endpoint name passed was having '$' MS would have picked
        // the endpoint that is free and hence we need the actual name here
        String userEndpoint = event.getConnection().getEndpoint();

        MsLink link = session.createLink(MsLinkMode.FULL_DUPLEX);
        link.join(userEndpoint, "media/trunk/Announcement/$");

    }

    public void connectionDeleted(<literal>MsConnection</literal>Event event) {

    }

    public void connectionInitialized(<literal>MsConnection</literal>Event event) {
        // TODO Auto-generated method stub

    }

    public void connectionModifed(<literal>MsConnection</literal>Event event) {
        // TODO Auto-generated method stub

    }

    public void txFailed(<literal>MsConnection</literal>Event event) {
        // TODO Auto-generated method stub

    }

    public void linkCreated(MsLinkEvent evt) {

    }

    public void linkDropped(MsLinkEvent evt) {
        // TODO Auto-generated method stub

    }

    public void linkFailed(MsLinkEvent evt) {
        // TODO Auto-generated method stub

    }

    public void linkJoined(MsLinkEvent evt) {
        // Get the MsLink when link between Packet Relay Endpoint and
        // Announcement Endpoint is created
        MsLink link = evt.getSource();

        // Get the Announcement Endpoint Name as we used '$'
        String announcementEndpoint = link.getEndpoints()[1];

        // let us create MsSignalGenerator for Announcement Endpoint to play
        // Announcement
        MsSignalGenerator generator = msProvider.getSignalGenerator(announcementEndpoint);

        // This is hosted audio file, it can be a local file on your machine
        // For example for windows file://c:/mobicents/loopinfo.wav" for linux
        // file://user/home/loopinfo.wav"
        String url = "http://localhost:8080/msdemo/audio/loopinfo.wav";

        // Pass the URL of audio file to be played
        generator.apply(EventID.PLAY, new String[] { url });

    }
}]]></programlisting>
</example>
	</section>
</section>

