<document>
	<properties>
		<title>JBoss Seam Integration</title>
	</properties>
	<body>
	<section name="JBoss Seam Integration Overview">
		<p>
				<a href="http://www.seamframework.org/">JBoss Seam</a> components can now handle real SipServletRequests and Media Server events while taking advantage of the Seam perks - bijection, scoping, transaction management, interceptors and everything else.
		</p>
		<p>
			Your SIP and HTTP Servlets are running in the same servlet context and they share the same application-scoped components, while the session-scoped components are mapped to the respective SIP and HTTP sessions. You can work with both EJBs and POJOs, interact with your web-layer, and still build very loosely coupled telco components working on the same messages without being aware of each-other. Seam provides synchronous and asynchronous light-weight message passing through the @Observer-annotated methods, which covers most of the communication needs in converged applications.
		</p>
		</section>
		<section name="How it works?">
			<p>The Seam 2 core is now mostly independent of HTTP Servlets and JSF. Basically we hooked a controller Sip Servlet and session listeners to the Seam lifecycle to control the context assignment for incoming SIP messages. When a SIP message arrives, we raise Seam events to notify the Seam components subscribed to receive the SIP events. We had to use a small Java reflection hack to reach some protected Seam contexts, but I believe it is safe. We will try to make it more clean.
</p><p>The Media Server events occur in the context of a SIP session and are treated in a similar way as the SIP events. You just subscribe methods with @Observer and process them as regular Media Server listener notifications.</p><p>
	The setup is straightforward - just add the controller servlet to your Seam application in a Sip Servlets container and it's ready to go. For now you can start with the sample application.
</p><p>
	Theoretically this technique can work on any JSR289-compliant container that supports JBoss Seam, but I have only tested it on Mobicents Sip Servlets 0.6/0.7 with JBoss Application Server 4.2.3 and Seam 2.1.0.SP1.
</p>
		</section>	
		<section name="Example">
	<p>This is simple SIP service which responds to an INVITE and counts the number of messages per session. There is a session-scoped counter, which is incremented on every message. Note how you can subscribe methods to SIP events. You can subscribe as many methods as you like in any Seam component, they all will be notified.
</p>
<source>
@Name("simpleSeamSipService")
@Scope(ScopeType.STATELESS)
@Transactional
public class SimpleSeamSipService {
    @Logger Log log;
    @In SessionMessageCounter sessionMessageCounter;
    
    public void inc() {
        sessionMessageCounter.increment();
        log.info("Processed SIP messages " 
                + sessionMessageCounter.getMessages());
    }
    
    @Observer("INVITE")
    public void doInvite(SipServletRequest request) 
    throws Exception {
        inc();
        request.createResponse(180).send();
        Thread.sleep(100);
        request.createResponse(200).send();
    }
    
    @Observer("ACK")
    public void doAck(SipServletRequest request) 
    throws Exception {
        inc();
    }
    
    @Observer({"REGISTER","BYE"})
    public void doRegister(SipServletRequest request) 
    throws Exception {
        inc();
        request.createResponse(200).send();
    }
}
</source>

	<p>You should keep in mind that the Seam events are application-wide. If you need cross-application messaging use JMS. Seam would help a lot with JMS too.
</p><p>
	And this is the SIP-session scoped component:
</p>
<source>
@Name("sessionMessageCounter")
@Startup
@Scope(ScopeType.SESSION)
public class SessionMessageCounter {
    private int messages;
    
    public int getMessages() {
        return messages;
    }
    
    public void increment() {
        messages++;
    }
}
</source>

<p>	Actually, this component is created and stored in every Seam session, no matter if it's SIP or HTTP. This is a bit inefficient, but has some advantages. Ultimately we would want to have a separate SipSession and SipApplicationSession scopes in Seam and we will probably get there with the user-defined scopes in Web Beans (JSR 299) or a newer version of Seam.
</p>
		</section>
		<section name="Media Support">
			<p>The goal of the Seam Sip and Media framework is to add a
				lightweight media framework you can use to build Media-intensive
				applications. All Media events occur in the context of a SipSession
				and you can use the Sip Session to share state between the Media and
				SIP events.</p>
			<p>There are two main built-in components, both can be injected from anywhere</p>
			<source>
// the sipFactory for the application, it is SESSION-scoped
SipFactory sipFactory; 

// the factory for Media events like requesting playback or DTMF
MsEventFactory eventFactory; 

// The Media controller provides Media operations for creating
// connections and links in a seam-managed way. The MediaController
// suplicates some methods from the MSC API - createConnection, 
// createLink and execute. It is recommended to study
// the media-framework-demo for further information and usage.
// http://mobicents.googlecode.com/svn/trunk/servers/sip-servlets/sip-servlets-seam/media-framework-demo
MediaController mediaController;

			</source>
			<p>The SIP events being delivered are as follows</p>
			<source>
// Media Connection Events

@Observer("mediaEvent")
public void mediaEvent(MediaEvent mediaEvent) {}

@Observer("connectionCreated")
public void doConnectionEvent(MsConnectionEvent connectionEvent) {}

@Observer("connectionDisconnected")
public void doConnectionEvent(MsConnectionEvent connectionEvent) {}

@Observer("connectionFailed")
public void doConnectionEvent(MsConnectionEvent connectionEvent) {}

@Observer("connectionHalfOpen")
public void doConnectionEvent(MsConnectionEvent connectionEvent) {}

@Observer("connectionModeRecvOnly")
public void doConnectionEvent(MsConnectionEvent connectionEvent) {}

@Observer("connectionOpen")
public void doConnectionEvent(MsConnectionEvent connectionEvent) {}

@Observer("connectionModeSendRecv")
public void doConnectionEvent(MsConnectionEvent connectionEvent) {}

@Observer("connectionModeSendOnly")
public void doConnectionEvent(MsConnectionEvent connectionEvent) {}

// Media Link Events

@Observer("linkConnected")
public void doLinkEvent(MsLinkEvent linkEvent) {}

@Observer("linkCreated")
public void doLinkEvent(MsLinkEvent linkEvent) {}

@Observer("linkDisconnected")
public void doLinkEvent(MsLinkEvent linkEvent) {}

@Observer("linkFailed")
public void doLinkEvent(MsLinkEvent linkEvent) {}

@Observer("modeFullDuplex")
public void doLinkEvent(MsLinkEvent linkEvent) {}

@Observer("modeHalfDuplex")
public void doLinkEvent(MsLinkEvent linkEvent) {}
			</source>
			<p>You can handle these events and relate them to a sip session simply by injecting the SipSession object and you can store or read state from there as shown in the example below. We are reusing the
				MSC API objects with the excpetion of MediaEvent where the
				notification message is wrapped and carries more inforrmation than
				the original event structure. You can see the demo for more details.
			</p>
			<p>Here is an example conference application using the most
				common functions:</p>
			<source> 
@Name("conference")
@Scope(ScopeType.STATELESS)
public class Conference {
	@Logger Log log;
	@In MediaController mediaController;
	@In SipSession sipSession;
	
	@In(scope=ScopeType.APPLICATION, required=false)
	@Out(scope=ScopeType.APPLICATION, required=false)
	String conferenceEndpointName;
	
	@Observer("INVITE")
	public void doInvite(SipServletRequest request) throws Exception {
		String sdp = new String((byte[]) request.getContent());
		request.createResponse(180).send();
		sipSession.setAttribute("inviteRequest", request);
		if (conferenceEndpointName == null)
			conferenceEndpointName = "media/trunk/Conference/$";
		mediaController.createConnection(conferenceEndpointName).modify("$",
				sdp);
	}

	@Observer("connectionOpen")
	public void doConnectionOpen(MsConnectionEvent event) throws IOException {
		conferenceEndpointName = event.getConnection().getEndpoint()
				.getLocalName();
		SipServletRequest request = (SipServletRequest) sipSession
				.getAttribute("inviteRequest");
		SipServletResponse response = request.createResponse(200);
		response.setContent(event.getConnection().getLocalDescriptor(),
				"application/sdp");
		response.send();
	}

	@Observer( { "BYE", "REGISTER" })
	public void sayOK(SipServletRequest request) throws Exception {
		request.createResponse(200).send();
	}

}
</source>

		</section>
		<section name="Guidelines">
<ul><li><span style="font-weight: bold;">Do not subscribe methods to SIP and media events in Seam components with SESSION or CONVERSATION scopes! </span>The reason is that each of these SESSION or CONVERSATION scoped components is likely to have multiple instances (depending on the number of the sessions) and they all will be called, which is probably not what you want.</li><li><span style="font-weight: bold;">Always subscribe public methods to SIP and media events.</span> Any other access modifier will cause you method not to be called.</li><li><span style="font-weight: bold;">When dealing with JPA, always use your own EntityManager.</span> Either EVENT or METHOD scoped or manage it manually through the EntityManagerFactory. The default CONVERSATION-scoped entityManager might produce "EntityManager closed" errors.</li><li style="text-align: justify;"><span style="font-weight: bold;">When initiating a SIP request from a Web session, do it in another thread! </span>Seam uses thread-local storage and the Web contexts will collide with the SIP contexts. We are working on solving this issue and will probably be addressed in the future.</li><li style="text-align: justify;">Keep in mind that outjection occurs at the end of a method call. If you attempt to use an outjected variable from a nested method call, it will fail.<br/></li></ul>
</section>
		<section name="Advantages">

					<ul>
					<li><a href="http://docs.jboss.com/seam/latest/reference/en-US/html/index.html">All the Seam goodness.</a></li>
		
					<li>Development will be easier, because you can take advantage of the Seam <code>WEB-INF/dev</code> classloader to deploy Seam components faster. Otherwise you have to redeploy the whole war/ear (10-20 secs vs 1-2 secs). This feature is not perfect yet.</li>
							
					<li>Testing - Seam provides a great framework for testing based on dependency injection and mocking.</li>
					
					<li>Programming model is practically the same as the one you use for Web apps with Seam and similar to the future Web Beans.</li>
				
					<li>Potential to integrate with jBPM and JBoss Rules through Seam. (contributors?)</li>
				
					</ul>
		</section>	
		<section name="Disadvantages">

					<ul>
					<li>It is not standards-based.</li>
					<li>Performance is suffering a bit with Seam.</li>
				
					</ul>
						<p>You can find the entrypoint project and the sample applications in SVN:
	<a href="http://mobicents.googlecode.com/svn/trunk/servers/sip-servlets/sip-servlets-seam">http://mobicents.googlecode.com/svn/trunk/servers/sip-servlets/sip-servlets-seam</a></p>

		</section>				
	</body>
</document>