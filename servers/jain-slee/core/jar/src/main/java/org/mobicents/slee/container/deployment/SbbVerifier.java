/***************************************************
 *                                                 *
 *  Mobicents: The Open Source JSLEE Platform      *
 *                                                 *
 *  Distributable under LGPL license.              *
 *  See terms of license at gnu.org.               *
 *                                                 *
 ***************************************************/
/*
 * SbbVerifier.java
 * 
 * Created on Jul 26, 2004
 *
 */
package org.mobicents.slee.container.deployment;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import javassist.CtClass;
import javassist.CtField;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;

import javax.slee.ActivityContextInterface;
import javax.slee.Sbb;
import javax.slee.management.SbbDescriptor;

import org.jboss.logging.Logger;
import org.mobicents.slee.container.SleeContainer;
import org.mobicents.slee.container.component.CMPField;
import org.mobicents.slee.container.component.ComponentKey;
import org.mobicents.slee.container.component.DeployableUnitIDImpl;
import org.mobicents.slee.container.component.EventTypeIDImpl;
import org.mobicents.slee.container.component.GetChildRelationMethod;
import org.mobicents.slee.container.component.MobicentsEventTypeDescriptor;
import org.mobicents.slee.container.component.MobicentsSbbDescriptor;
import org.mobicents.slee.container.component.ProfileCMPMethod;
import org.mobicents.slee.container.component.SbbEventEntry;
import org.mobicents.slee.container.component.deployment.ClassPool;

/**
 * Verify that a sbb abstract class provided by a sbb developer is following a set of constraints.
 * <BR>This verifier checks that the sbb developer developed the Sbb Abstract class
 * following the slee specification requirements.<BR>
 * <BR>It verifies also that the Sbb Abstract class and the definitions provided 
 * by the sbb developer in the deployment descriptor are matching<BR> 
 * It verifies also the sbb concrete class generated by the slee runtime to check
 * the generated byte code integrity.
 * 
 * @author DERUELLE Jean <a href="mailto:jean.deruelle@gmail.com">jean.deruelle@gmail.com</a>
 * @author eduardomartins
 *
 */
public class SbbVerifier {

	/**
	 * the set of constraints defined by the slee specification
	 * on a sbb abstract class
	 */
	//private List constraints=null;
	/**
	 * deployment descriptor used to verified that the Sbb Abstract class and 
	 * the definitions in the deployment descriptor are matching 
	 */
	private MobicentsSbbDescriptor sbbDeploymentDescriptor = null;

	/**
	 * Pool to generate or read classes with javassist
	 */
	private ClassPool pool = null;
	/**
	 * Logger to logg information
	 */
	private static Logger logger = null;

	private String errorString;

	/** the class holder for javax.slee.Sbb */
	private CtClass sbbAbstractClass;

	static {
		logger = Logger.getLogger(SbbVerifier.class);

	}

	/**
	 * 
	 */
	public SbbVerifier(SbbDescriptor sbbDescriptor) {

		sbbDeploymentDescriptor = (MobicentsSbbDescriptor) sbbDescriptor;
		pool = ((DeployableUnitIDImpl) (sbbDescriptor.getDeployableUnit()))
				.getDUDeployer().getClassPool();
		try {
			Thread.currentThread().getContextClassLoader().loadClass(Sbb.class.getName());
			sbbAbstractClass = pool.get(Sbb.class.getName());
		} catch (Exception e) {
			String s = "Cannot find class ! while verifying ";
			logger.fatal(e);
			throw new RuntimeException(s, e);
		}
	}

	/**
	 * Verify that a sbb abstract class provided by a sbb developer is following 
	 * a set of constraints.
	 * @param sbbAbstractClassName name of the sbb abstract class provided by the user
	 * @return true is the sbb abstract class is safe
	 */
	public boolean verifySbbAbstractClass(String sbbAbstractClassName,
			SleeContainer serviceContainer) {

		try {

			// FIXME: this is obsolete, we don't want the class to be defined before it is inspected and enhanced
			// logger.info("Verifying "+ profileTransientStateClass(sbbAbstractClassName).getName());
			// CtClass ctClass=pool.get(sbbAbstractClassName);

			/*
			 * Load the abstract class definition in memory, but do not make it visible via the classloader yet 
			 */
			if (logger.isDebugEnabled()) {
				logger.debug("Verifying " + sbbAbstractClassName);
			}
			ClassLoader cl = (ClassLoader) Thread.currentThread()
					.getContextClassLoader();
			String classRsrcName = sbbAbstractClassName.replace('.', '/')
					+ ".class";
			InputStream sbbAbstractClassIS = cl
					.getResourceAsStream(classRsrcName);
			if (sbbAbstractClassIS == null) {
				logger.error("Cannot open input stream for " + classRsrcName);
				return false;
			}

			CtClass ctClass = null;
			try {
				ctClass = pool.get(sbbAbstractClassName);
				ctClass.detach();				
			} catch (NotFoundException e) {				
				//e.printStackTrace();
			}
			ctClass = pool.makeClass(sbbAbstractClassIS);

			if (!checkSbbAbstractClassConstraints(ctClass)) {
				logger
						.error("SbbAbstractClass Constraints were not successfully verified");
				return false;
			}

			if (!checkSbbAgainstDeploymentDescriptor(ctClass, serviceContainer)) {
				logger.error("Sbb and deployment descriptor are not matching");
				return false;
			}

			if (!this.checkEventHandlerMethods(ctClass, serviceContainer)) {
				logger
						.error("EventHandler Methods were not successfully verified");
				return false;
			}

		} catch (IOException ioe) {
			logger.error("Sbb Abstract Class validation failed for: "
					+ sbbAbstractClassName, ioe);
			return false;
		}

		if (logger.isDebugEnabled()) {
			logger.debug(sbbAbstractClassName + " verified");
		}
		return true;
	}

	/**
	 * Verify the sbb concrete class generated by the slee runtime to check
	 * the generated byte code integrity.
	 * @param sbbConcreteClassName name of the sbb abstract class provided by the user
	 * @return true is the sbb concrete class is safe
	 */
	public boolean verifySbbConcreteClass(String sbbConcreteClassName) {
		return false;
	}

	/**
	 * Check the constraints defined by the slee specification final release 1.0
	 * on an Sbb Abstract Class : 
	 * The class must implement, directly or indirectly, the javax.slee.Sbb interface.
	 *	· The class must be defined as public and must be abstract.
	 *	· The class must not define the finalize method
	 *  · The SBB Developer must provide a public constructor that takes no arguments.
	 * @param sbbAbstractClass class, provided by the sbb developer, to check
	 * @return true if the class is safe
	 */
	protected boolean checkSbbAbstractClassConstraints(CtClass sbbAbstractClass) {
		int modifiers = sbbAbstractClass.getModifiers();
		//check that the class modifiers contain abstratc and public
		if (!Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)) {
			logger.error("The class is nor abstract neither public");
			return false;
		}
		//check that the finalize method is not present in the class
		CtMethod[] methods = sbbAbstractClass.getDeclaredMethods();
		if (methods != null) {
			for (int i = 0; i < methods.length; i++) {
				CtMethod method = methods[i];
				if (method.getName().equalsIgnoreCase("finalize")) {
					logger
							.error("finalize method is present in the sbb abstract class "
									+ sbbAbstractClass.getName());
					return false;
				}
				if (methods[i].getName().startsWith("ejb")) {
					logger.error("invalid method name detected "
							+ methods[i].getName());
					return false;
				}

				if (methods[i].getName().startsWith("sbb")) {
					if (logger.isDebugEnabled())
						logger.debug("checking method " + methods[i].getName());
					CtMethod[] abstractClassMethods = this.sbbAbstractClass
							.getDeclaredMethods();
					int k;
					for (k = 0; k < abstractClassMethods.length; k++) {
						CtMethod ctMethod = abstractClassMethods[k];
						if (ctMethod.getName().equals(methods[i].getName()))
							break;
					}
					// Not an abstract method so it is invalid.
					if (k == abstractClassMethods.length) {
						logger.error("invalid method name determined "
								+ methods[i].getName());
						return false;
					}
				}
			}
		} else {
			logger
					.error("there is no abstract methods inthis abstract Class : "
							+ sbbAbstractClass.getName());
			return false;
		}
		//check that the method implements the Sbb class either directly or by inheritance
		try {
			boolean implementSbbLinkFound = false;
			implementSbbLinkFound = checkInterfaces(sbbAbstractClass
					.getInterfaces(), "javax.slee.Sbb");
			CtClass superClass = sbbAbstractClass.getSuperclass();
			while (superClass != null && !implementSbbLinkFound) {
				if (superClass.getName().equalsIgnoreCase("javax.slee.Sbb"))
					implementSbbLinkFound = true;
				else {
					implementSbbLinkFound = checkInterfaces(superClass
							.getInterfaces(), "javax.slee.Sbb");
					superClass = superClass.getSuperclass();
				}
			}
			if (!implementSbbLinkFound) {
				logger
						.error("sbb abstract class "
								+ sbbAbstractClass.getName()
								+ " doesn't implements the javax.slee.Sbb class either directly or by inheritance");
				return false;
			}
		} catch (NotFoundException nfe) {
			nfe.printStackTrace();
			return false;
		}
		//check that the class has a public constructor without any arguments        
		/**CtConstructor[] constructors=sbbAbstractClass.getConstructors();
		boolean defaultConstructorFound=false;
		if(constructors!=null){            
		    try{
		        for(int i=0;i<constructors.length;i++){
		            constructors[i].getParameterTypes();                
		        }
		    }
		    catch(NotFoundException nfe){
		        defaultConstructorFound=true;
		    }
		}
		else
		    return false;
		
		if(!defaultConstructorFound)
		    return false;**/
		//check that the field names do not start with sbb or ejb
		CtField[] ctFields = sbbAbstractClass.getFields();
		for (int i = 0; i < ctFields.length; i++) {
			if (Modifier.isPublic(ctFields[i].getModifiers())
					&& (ctFields[i].getName().startsWith("sbb") || ctFields[i]
							.getName().startsWith("ejb"))) {
				logger.error("the sbb abstract class "
						+ sbbAbstractClass.getName()
						+ " has a field starting with sbb or ejb["
						+ (!Modifier.isPrivate(ctFields[i].getModifiers()))
						+ "]: " + ctFields[i].getName());
				return false;
			}
		}

		return true;
	}

	/**
	 * Check if among the interfaces one is the class searched
	 * @param interfaces the interfaces
	 * @param interfaceSearched the interface to look for
	 * return true if among the interfaces one is the class searched
	 */
	private boolean checkInterfaces(CtClass[] interfaces,
			String interfaceSearched) {
		if (interfaces == null) {
			if (logger.isDebugEnabled()) {
				logger.debug("no interfaces");
			}
			return false;
		}
		for (int i = 0; i < interfaces.length; i++) {
			if (interfaces[i].getName().equalsIgnoreCase(interfaceSearched)) {
				return true;
			}
		}
		if (logger.isDebugEnabled()) {
			logger.debug("interfaces are zero length");
		}
		return false;
	}

	/**
	 * Check that the sbb abstract class correclty implements what is defined
	 * in the deployment descriptor
	 * For each method defined by the SBB Developer, there must be a matching method in
	 * the SBB abstract class. The matching method must have:
	 * 		o The same name.
	 *	    o The same number of arguments, and same argument and return types.
	 *	    o The same set of exceptions in the throws clause.
	 * param sbbAbstractClass the sbb abstract class to check
	 * @return true if the sbb abstract class correclty implements what is defined
	 * in the deployment descriptor
	 */
	protected boolean checkSbbAgainstDeploymentDescriptor(
			CtClass sbbAbstractClass, SleeContainer serviceContainer) {
		if (logger.isDebugEnabled()) {
			logger.debug("checkSbbAgainstDeploymentDescriptor started");
		}
		Map abstractMethods = ClassUtils
				.getAbstractMethodsFromClass(sbbAbstractClass);
		//Set implementedMethods=ClassUtils.getConcreteMethodsNamesFromClass(sbbAbstractClass);
		Map superClassesAbstractMethods = ClassUtils
				.getSuperClassesAbstractMethodsFromClass(sbbAbstractClass);
		if (logger.isDebugEnabled()) {
			logger
					.debug("checkSbbAgainstDeploymentDescriptor abstract methods retrieved");
		}
		//Check CMP fields
		CMPField[] cmpFields = sbbDeploymentDescriptor.getCMPFields();
		if (logger.isDebugEnabled()) {
			logger
					.debug("checkSbbAgainstDeploymentDescriptor CMP Fields retrieved ");
		}

		//this is because cmpFields is not a copy of array - its actually reference to array inside
		//sbbdepdesc
		CMPField[] tmpBackUpFields = new CMPField[cmpFields.length];
		for (int c = 0; c < cmpFields.length; c++)
			tmpBackUpFields[c] = cmpFields[c];
		//LETS LOOSE ORIGINAL ONES.
		cmpFields = tmpBackUpFields;
		if (logger.isDebugEnabled()) {
			logger
					.debug("checkSbbAgainstDeploymentDescriptor CMP Fields retrieved ");
			Iterator it = abstractMethods.keySet().iterator();
			StringBuffer sb = new StringBuffer(300);
			while (it.hasNext()) {
				sb.append("[ " + it.next() + " ]");
			}
			logger.debug("\n=============== ABSTRACT METHODS FOR: "
					+ sbbAbstractClass.getName() + " ================\n" + sb
					+ "\n=============================================");

			sb = new StringBuffer(300);
			for (int c = 0; c < cmpFields.length; c++) {
				if (cmpFields[c] != null)
					sb.append("[ " + cmpFields[c].getFieldName() + " ]");
				else
					sb.append("[ " + cmpFields[c] + " ]");
			}
			logger.debug("\n=============== CMPFIELDS FOR: "
					+ sbbAbstractClass.getName() + " ================\n" + sb
					+ "\n=============================================");
		}
		if (cmpFields != null) {
			CtClass localSbbAbstractClass = sbbAbstractClass;
			for (CMPField cmpField : cmpFields) {
				if (!checkCMPFieldAgainstDeploymentDescripor(abstractMethods,
						cmpField, localSbbAbstractClass)) {
					if (!checkCMPFieldAgainstDeploymentDescripor(
							superClassesAbstractMethods, cmpField,
							localSbbAbstractClass)) {
						logger.error("CMPFIELD " + cmpField.getFieldName()
								+ " not verified with success.");
						return false;
					}
				}
			}
		}
		if (logger.isDebugEnabled()) {
			logger.debug("checkSbbAgainstDeploymentDescriptor CMP Fields ok");
		}
		//Check the presence of the get child relation methods
		GetChildRelationMethod[] getChildRelationMethods = sbbDeploymentDescriptor
				.getChildRelationMethods();

		if (getChildRelationMethods != null) {
			for (int i = 0; i < getChildRelationMethods.length; i++) {
				String methodName = getChildRelationMethods[i].getMethodName();
				CtMethod getChildRelationMethod = (CtMethod) abstractMethods
						.get(methodName);
				if (getChildRelationMethod == null) {
					getChildRelationMethod = (CtMethod) superClassesAbstractMethods
							.get(methodName);
					if (getChildRelationMethod == null) {
						logger
								.error("integrity compromised on sbbAbstractClass "
										+ sbbAbstractClass.getName()
										+ " GetChildRelationMethod "
										+ methodName
										+ " defined in the descriptor is missing");
						return false;
					}
				}
				//The method has been verified so it is removed from the abstract method map
				abstractMethods.remove(methodName);
			}
		}
		if (logger.isDebugEnabled()) {
			logger.debug("get child relation methods ok");
		}

		if (!checkProfileCMPMethods(sbbAbstractClass, abstractMethods,
				superClassesAbstractMethods))
			return false;

		//Check the presence of the activity context interface narrow method
		Class activityContextInterface = sbbDeploymentDescriptor
				.getActivityContextInterface();
		if (activityContextInterface != null) {
			String activityContextInterfaceName = activityContextInterface
					.getName();
			if (logger.isDebugEnabled()) {
				logger.debug(activityContextInterface.getName());
			}
			CtMethod narrowMethod = (CtMethod) abstractMethods
					.get("asSbbActivityContextInterface");
			if (narrowMethod == null) {
				narrowMethod = (CtMethod) superClassesAbstractMethods
						.get("asSbbActivityContextInterface");
				if (narrowMethod == null) {
					logger
							.error("integrity compromised on sbbAbstractClass "
									+ sbbAbstractClass.getName()
									+ " narrow method asSbbActivityContextInterface with the return type"
									+ activityContextInterfaceName
									+ " defined in the descriptor is missing");
					return false;
				}
			}
			try {
				if (!narrowMethod.getReturnType().getName().equals(
						activityContextInterfaceName)) {
					logger
							.error("integrity compromised on sbbAbstractClass "
									+ sbbAbstractClass.getName()
									+ " narrow method asSbbActivityContextInterface with the return type"
									+ activityContextInterfaceName
									+ " has in the abstract method a return type different "
									+ narrowMethod.getReturnType().getName());
					return false;
				}
			} catch (NotFoundException e) {
				logger
						.error("integrity compromised on sbbAbstractClass "
								+ sbbAbstractClass.getName()
								+ " narrow method asSbbActivityContextInterface with the return type"
								+ activityContextInterfaceName
								+ " has a no return type");
			}
			//The method has been verified so it is removed from the abstract method map
			abstractMethods.remove("asSbbActivityContextInterface");
		}
		if (logger.isDebugEnabled()) {
			logger.debug("asSbbActivityContextInterface ok");
		}
		//Check the presence of fire Event methods
		//and list of  params -- it shoudl have 3 of them
		//(EventClass,ActivityContextInterface , Address )
		HashSet sbbEventEntries = sbbDeploymentDescriptor.getSbbEventEntries();

		if (sbbEventEntries != null) {
			Iterator it = sbbEventEntries.iterator();
			//firedEvents
			while (it.hasNext()) {
				SbbEventEntry sbbEventEntry = (SbbEventEntry) it.next();
				if (sbbEventEntry.isFired()) {

					String eventName = sbbEventEntry.getEventName();
					ComponentKey cKey = sbbEventEntry.getEventTypeRefKey();
					EventTypeIDImpl eventTypeID = serviceContainer
							.getEventManagement().getEventType(cKey);

					//WE HAVE TO BE SURE SLEE KNOWS SOMETHING
					if (eventTypeID == null) {
						logger.error("event type id: " + eventName
								+ " is unknown to the SLEE");
						return false;

					}

					String methodName = "fire" + sbbEventEntry.getEventName();
					CtMethod fireEventMethod = (CtMethod) abstractMethods
							.get(methodName);
					if (fireEventMethod == null) {
						//search fire method in superClass
						fireEventMethod = (CtMethod) superClassesAbstractMethods
								.get(methodName);
					}
					if (fireEventMethod != null) {
						//NOW WE HAVE TO CHECK PARAMS
						abstractMethods.put(methodName, fireEventMethod);
						MobicentsEventTypeDescriptor eventTypeDescriptor = serviceContainer
								.getEventManagement().getEventDescriptor(
										eventTypeID);
						String eventClassName = eventTypeDescriptor
								.getEventClassName();

						CtClass[] params = null;
						CtClass retType = null;
						try {
							params = fireEventMethod.getParameterTypes();
							retType = fireEventMethod.getReturnType();
						} catch (NotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						if (params == null || params.length == 0) {
							logger
									.error("integrity compromised on sbbAbstractClass "
											+ sbbAbstractClass.getName()
											+ " on fire event method: "
											+ fireEventMethod + " => no params");
							return false;
						}
						if (params.length != 3) {

							this.errorString = "bad method signature ( wrong number of params!)";
							logger.error(errorString);
							return false;
						}

						if (retType != CtClass.voidType) {
							this.errorString = "fired methods must have void return type";
							logger.error(errorString);
							return false;
						}

						if (!Modifier.isPublic(fireEventMethod.getModifiers())) {
							this.errorString = "Fire event method: "
									+ fireEventMethod.getName() + " for "
									+ sbbEventEntry.getEventTypeRefKey()
									+ " MUST BE PUBLIC";
							logger.error(errorString);
							return false;
						}
						if (!Modifier
								.isAbstract(fireEventMethod.getModifiers())) {
							this.errorString = "Fire event method: "
									+ fireEventMethod.getName() + " for "
									+ sbbEventEntry.getEventTypeRefKey()
									+ " MUST BE ABSTRACT";
							logger.error(errorString);
							return false;
						}
						//TODO: EXCEPTIONS CHECK?
						//IT CANT HAVE THROWS clause
						/* CtClass exceptions[]=null;
						 try {
							 exceptions=fireEventMethod.getExceptionTypes();
						} catch (NotFoundException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						if(exceptions!=null || exceptions.length>0)
						{
							this.errorString = "bad fire method signature, fire method can not have throws clause";
						    logger.error( errorString );                    
						    return false;
						}*/

						//NOW LETS CHECK PARAMS
						//[0] - event class
						CtClass param = params[0];

						if (!param.getName().equals(eventClassName)) {
							this.errorString = "bad fire method signature expected parameter[0] "
									+ eventClassName;
							logger.error(errorString);
							return false;
						}
						//[1] - aci or custom aci (or is it only generic ACI?)
						param = params[1];

						String customACIName = sbbDeploymentDescriptor
								.getActivityContextInterfaceClassName();
						if (customACIName != null) { // This is a custom SBB activity context interface
							if (!customACIName.equals(param.getName())
									&& !param.getName().equals(
											ActivityContextInterface.class
													.getName())) {
								this.errorString = "bad fire method signature expected parameter[1] "
										+ customACIName
										+ " or "
										+ ActivityContextInterface.class
												.getName();
								logger.error(errorString);
								return false;
							}

						} else if (!param.getName().equals(
								ActivityContextInterface.class.getName())) { // Not a custom ACI
							this.errorString = "bad fire method signature expected parameter[1] "
									+ ActivityContextInterface.class.getName();
							logger.error(errorString);
							return false;
						}

						//[2] - address -> javax.slee.Address ????
						param = params[2];
						if (!param.getName().equals(
								javax.slee.Address.class.getName())) {
							this.errorString = "bad fire method signature expected parameter[2] "
									+ javax.slee.Address.class.getName();
							logger.error(errorString);
							return false;
						}
						//The method has been verified so it is removed from the abstract method map
						abstractMethods.remove(methodName);
					} else {
						logger
								.error("integrity compromised on sbbAbstractClass "
										+ sbbAbstractClass.getName()
										+ " fireEventMethod "
										+ methodName
										+ " defined in the descriptor is missing");
						return false;
					}

					abstractMethods.remove(methodName);
				}

			}
		}
		if (logger.isDebugEnabled()) {
			logger.debug("sbbEventEntries ok");
		}
		//TODO check the other methods declared in the descriptor
		//sbb local interface 
		//Usage parameter method is generated by us. 
		CtMethod getDefaultSbbUsageParameterSetMethod = (CtMethod) abstractMethods
				.get("getDefaultSbbUsageParameterSet");
		if (getDefaultSbbUsageParameterSetMethod != null) {
			if (logger.isDebugEnabled()) {
				logger
						.debug("getDefaultUsageParameterSet abstract method found in the SBB.");
			}
			String usageParameterInterfaceName = this.sbbDeploymentDescriptor
					.getUsageParametersInterface();
			if (usageParameterInterfaceName == null) {
				logger
						.error("No Usage parameter found in the descriptor corresponding to the getDefaultSbbUsageParameterSet defined in the SBB!");
				return false;
			}

			try {
				String returnType = getDefaultSbbUsageParameterSetMethod
						.getReturnType().getName();
				if (logger.isDebugEnabled()) {
					logger
							.debug("RETURN TYPE: " + returnType
									+ " INTERFACE NAME: "
									+ usageParameterInterfaceName);
				}
				if (returnType.compareTo(usageParameterInterfaceName) != 0) {
					logger
							.error("The return type of getDefaultSbbUsageParameterSet defined in the SBB does not match the interface name in the descriptor!");
					return false;
				}
			} catch (NotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			CtClass[] params = null;
			try {
				params = getDefaultSbbUsageParameterSetMethod
						.getParameterTypes();
			} catch (NotFoundException ex) {

			}
			if (params != null && params.length != 0) {
				logger
						.error("Unexpected parameter found"
								+ params[0].getName());
				return false;
			}
			abstractMethods.remove("getDefaultSbbUsageParameterSet");
		}
		if (logger.isDebugEnabled()) {
			logger.debug("getDefaultSbbUsageParameterSet ok");
		}
		//Named Usage Parameter method is generated by us.
		CtMethod getSbbUsageParameterSet = (CtMethod) abstractMethods
				.get("getSbbUsageParameterSet");
		if (getSbbUsageParameterSet != null) {
			CtClass[] params = null;
			try {
				params = getSbbUsageParameterSet.getParameterTypes();
				if (params.length != 1) {
					logger.error("too many args!");
					return false;
				}
				if (!(params[0].getName().equals(String.class.getName()))) {
					logger.error("Arg type must be String!");
					return false;
				}
			} catch (NotFoundException ex) {
				logger.error("Expected parameter not found");
				return false;
			}
			abstractMethods.remove("getSbbUsageParameterSet");
		}
		if (logger.isDebugEnabled()) {
			logger.debug("getSbbUsageParameterSet ok");
		}

		//Check if some methods have not been verfied
		if (abstractMethods.size() > 0) {
			logger
					.error("Some methods have not been verified against the sbb descriptor"
							+ ", maybe these methods have not been described in the descriptor and so are not allowed. \n"
							+ " The following method(s) were not matched against the descriptor:"
							+ abstractMethods.keySet());
			return false;
		}
		abstractMethods = null;
		if (logger.isDebugEnabled()) {
			logger.debug("SbbAbstractClass " + sbbAbstractClass.getName()
					+ " follows the descriptor");
		}
		return true;
	}

	/**logger.debug("getSbbUsageParameterSet 
	 * @param sbbAbstractClass
	 * @param abstractMethods
	 * @param superClassesAbstractMethods
	 * @return
	 */
	private boolean checkProfileCMPMethods(CtClass sbbAbstractClass,
			Map abstractMethods, Map superClassesAbstractMethods) {
		//private boolean checkProfileCMPMethods(CtClass sbbAbstractClass, Map abstractMethods){
		//Check the presence of the profile CMP methods
		ProfileCMPMethod[] profileCMPMethods = sbbDeploymentDescriptor
				.getProfileCMPMethods();
		if (profileCMPMethods != null) {
			for (int i = 0; i < profileCMPMethods.length; i++) {
				String methodName = profileCMPMethods[i].getProfileCMPMethod();
				CtMethod profileCMPMethod = (CtMethod) abstractMethods
						.get(methodName);
				if (profileCMPMethod == null) {
					profileCMPMethod = (CtMethod) superClassesAbstractMethods
							.get(methodName);
					if (profileCMPMethod == null) {
						logger
								.error("integrity compromised on sbbAbstractClass "
										+ sbbAbstractClass.getName()
										+ " ProfileCMPMethod "
										+ methodName
										+ " defined in the descriptor is missing");
						return false;
					}
				} else {
					if (profileCMPMethod.getName().startsWith("sbb")
							|| profileCMPMethod.getName().startsWith("ejb")) {
						logger
								.error("integrity compromised on sbbAbstractClass "
										+ sbbAbstractClass.getName()
										+ " ProfileCMPMethod "
										+ methodName
										+ " should not starts with sbb or ejb in its name");
						return false;
					}
					CtClass[] parameters;
					try {
						parameters = profileCMPMethod.getParameterTypes();
						if (parameters.length != 1) {
							logger
									.error("integrity compromised on sbbAbstractClass "
											+ sbbAbstractClass.getName()
											+ " ProfileCMPMethod "
											+ methodName
											+ " should have one and only argument "
											+ "of type javax.slee.profile.ProfileID");
							return false;
						} else {
							if (!parameters[0].getName().equals(
									"javax.slee.profile.ProfileID")) {
								logger
										.error("integrity compromised on sbbAbstractClass "
												+ sbbAbstractClass.getName()
												+ " ProfileCMPMethod "
												+ methodName
												+ " should have one and only argument "
												+ "of type javax.slee.profile.ProfileID");
								return false;
							}
						}
					} catch (NotFoundException e) {
						logger
								.error("integrity compromised on sbbAbstractClass "
										+ sbbAbstractClass.getName()
										+ " ProfileCMPMethod "
										+ methodName
										+ " should have one argument of type javax.slee.profile.ProfileID");
						return false;
					}
					try {
						CtClass[] exceptions = profileCMPMethod
								.getExceptionTypes();
						if (exceptions.length < 2) {
							logger
									.error("integrity compromised on sbbAbstractClass "
											+ sbbAbstractClass.getName()
											+ " ProfileCMPMethod "
											+ methodName
											+ " should have both exceptions "
											+ "of type javax.slee.profile.UnrecognizedProfileNameException and "
											+ "javax.slee.profile.UnrecognizedProfileTableNameException declared thrown");
							return false;
						} else {
							boolean profileNameExceptionThrown = false;
							boolean profileTableNameExceptionThrown = false;
							int j = 0;
							while (j < exceptions.length
									&& (!profileNameExceptionThrown || !profileTableNameExceptionThrown)) {
								if (exceptions[j]
										.getName()
										.equals(
												"javax.slee.profile.UnrecognizedProfileNameException"))
									profileNameExceptionThrown = true;
								if (exceptions[j]
										.getName()
										.equals(
												"javax.slee.profile.UnrecognizedProfileNameException"))
									profileTableNameExceptionThrown = true;
								j++;
							}
							if (!profileNameExceptionThrown) {
								logger
										.error("integrity compromised on sbbAbstractClass "
												+ sbbAbstractClass.getName()
												+ " ProfileCMPMethod "
												+ methodName
												+ " should have this exception "
												+ "of type javax.slee.profile.UnrecognizedProfileNameException "
												+ "declared thrown");
								return false;
							}
							if (!profileTableNameExceptionThrown) {
								logger
										.error("integrity compromised on sbbAbstractClass "
												+ sbbAbstractClass.getName()
												+ " ProfileCMPMethod "
												+ methodName
												+ " should have this exception "
												+ "of type javax.slee.profile.UnrecognizedProfileTableNameException "
												+ "declared thrown");
								return false;
							}
						}
					} catch (NotFoundException e) {
						logger
								.error("integrity compromised on sbbAbstractClass "
										+ sbbAbstractClass.getName()
										+ " ProfileCMPMethod "
										+ methodName
										+ " should have both exceptions "
										+ "of type javax.slee.profile.UnrecognizedProfileNameException and "
										+ "javax.slee.profile.UnrecognizedProfileTableNameException declared thrown");
						return false;
					}
					ComponentKey componentKey = profileCMPMethods[i]
							.getProfileSpecKey();
					//TODO check that the return type is equals to the profileCMP interface
					//specified in the profile descriptor deployment
				}
				//The method has been verified so it is removed from the abstract method map
				abstractMethods.remove(methodName);
			}
		}
		if (logger.isDebugEnabled()) {
			logger.debug("profiles CMP methods ok");
		}
		return true;
	}

	/**
	 * Check that for the CMP fields defined in the sbbDeployment descriptor
	 * there is at least one accessor.
	 * If the CMP field has a getter :
	 * 		the getter should have a return type
	 * 		the getter should not have any parameters
	 * If the CMP field has a setter :
	 * 		the getter should not have a return type
	 * 		the getter should have one parameter 
	 * @param abstractMethods the abstract Method of the abstract class
	 * @param cmpFields the CMP Fields to check
	 * @param sbbAbstractClass the sbb abstract class 
	 * @return true if the CMP fields follow the constraints false otherwise
	 */
	private boolean checkCMPFieldAgainstDeploymentDescripor(
			Map abstractMethods, CMPField cmpField, CtClass sbbAbstractClass) {

		// first char must be lower case
		if (!Character.isLowerCase(cmpField.getFieldName().charAt(0))) {
			return false;
		}

		//Set the first char of the accessor to UpperCase to follow the javabean requirements
		String fieldName = cmpField.getFieldName().substring(0, 1)
				.toUpperCase()
				+ cmpField.getFieldName().substring(1);

		CtMethod setterAccessor = (CtMethod) abstractMethods.get("set"
				+ fieldName);
		CtMethod getterAccessor = (CtMethod) abstractMethods.get("get"
				+ fieldName);

		if (setterAccessor == null) {
			if (logger.isDebugEnabled()) {
				logger.debug("no setter method in sbbAbstractClass "
						+ sbbAbstractClass.getName() + " for CMP Field "
						+ fieldName);
			}
			return false;
		} else if (getterAccessor == null) {
			if (logger.isDebugEnabled()) {
				logger.debug("no getter method in sbbAbstractClass "
						+ sbbAbstractClass.getName() + " for CMP Field "
						+ fieldName);
			}
			return false;
		} else {
			// both method exists
			if (logger.isDebugEnabled()) {
				logger
						.debug("found setter and getter methods in sbbAbstractClass "
								+ sbbAbstractClass.getName()
								+ " for CMP Field " + fieldName);
			}
			// check that the getter accessor has a return type
			try {
				CtClass returnType = getterAccessor.getReturnType();
				if (returnType.getName().equalsIgnoreCase("void")) {
					logger.error("integrity compromised on sbbAbstractClass "
							+ sbbAbstractClass.getName() + " on CMP Field "
							+ fieldName
							+ " => getter method has no return type");
					return false;
				}
			} catch (NotFoundException nfe) {
				logger.error("integrity compromised on sbbAbstractClass "
						+ sbbAbstractClass.getName() + " on CMP Field "
						+ fieldName + " => getter method has no return type");
				return false;
			}
			//check that the getter accessor has no parameters
			try {
				CtClass[] parameterTypes = getterAccessor.getParameterTypes();
				if (parameterTypes != null && parameterTypes.length > 0) {
					logger.error("integrity compromised on sbbAbstractClass "
							+ sbbAbstractClass.getName() + " on CMP Field "
							+ fieldName
							+ " => getter method has some parameters");
					return false;
				}
			} catch (NotFoundException nfe) {
			}

			//check that the setter accessor has no return type
			try {
				CtClass returnType = setterAccessor.getReturnType();
				if (!returnType.getName().equalsIgnoreCase("void")) {
					logger.error("integrity compromised on sbbAbstractClass "
							+ sbbAbstractClass.getName() + " on CMP Field "
							+ fieldName
							+ " => setter method has a return type "
							+ returnType.getName());
					return false;
				}
			} catch (NotFoundException nfe) {
			}
			//check that the setter accessor has one parameter
			try {
				CtClass[] parameterTypes = setterAccessor.getParameterTypes();
				if (parameterTypes.length != 1) {
					logger
							.error("integrity compromised on sbbAbstractClass "
									+ sbbAbstractClass.getName()
									+ " on CMP Field "
									+ fieldName
									+ " => setter method has the wrong number of parameters");
					return false;
				}
			} catch (NotFoundException nfe) {
				logger.error("integrity compromised on sbbAbstractClass "
						+ sbbAbstractClass.getName() + " on CMP Field "
						+ fieldName + " => setter method has no parameters");
				return false;
			}

			// cross depedencies check
			try {
				//check that getter return type == setter parameter type == xml type
				CtClass getterReturnType = getterAccessor.getReturnType();
				CtClass[] setterParamTypes = setterAccessor.getParameterTypes();

				CtClass setterParamType = setterParamTypes[0];
				if (!getterReturnType.equals(setterParamType)) {
					logger
							.error("integrity compromised on sbbAbstractClass "
									+ sbbAbstractClass.getName()
									+ " on CMP Field "
									+ fieldName
									+ " => getter return type is not same as setter parameter type");
					return false;
				}

				if (cmpField.getSbbComponentKey() != null) {

					try {
						//Then the getter return type, setter param type should be SbbLocalObject
						if (logger.isDebugEnabled()) {
							logger.debug("Getter return type is: "
									+ getterReturnType.getName());
						}

						//FIXME - This is a bit slow

						Class cl = Thread.currentThread()
								.getContextClassLoader().loadClass(
										getterReturnType.getName());
						Class sbbLOClass = Thread.currentThread()
								.getContextClassLoader().loadClass(
										"javax.slee.SbbLocalObject");

						if (!sbbLOClass.isAssignableFrom(cl)) {
							logger
									.error("integrity compromised on sbbAbstractClass "
											+ sbbAbstractClass.getName()
											+ " on CMP Field "
											+ fieldName
											+ " => getter and setter types for an sbb ref must be SbbLocalObject");
							return false;
						}
					} catch (Exception e) {
						logger.error("Failed check ref param", e);
						return false;
					}
				}
			} catch (NotFoundException nfe) {
				logger
						.error("integrity compromised on sbbAbstractClass "
								+ sbbAbstractClass.getName()
								+ " on CMP Field "
								+ fieldName
								+ " => getter/setter accessor has no parameters/return type");
				return false;
			}

			// the methods have been verified so they are removed from the abstract method map
			abstractMethods.remove(setterAccessor.getName());
			abstractMethods.remove(getterAccessor.getName());
		}

		return true;
	}

	/**
	 * Check the event handler method signatures. The SBB developer must implement these. These must
	 * be recognized events in the slee else the Sbb is not valid.
	 * 
	 * @param sbbAbstractClass -- The abstract class to check.
	 * @param serviceContainer -- service container in which the event descriptors are installed.
	 */
	private boolean checkEventHandlerMethods(CtClass sbbAbstractClass,
			SleeContainer serviceContainer) {

		HashSet sbbEventEntries = this.sbbDeploymentDescriptor
				.getSbbEventEntries();

		for (Iterator it = sbbEventEntries.iterator(); it.hasNext();) {
			SbbEventEntry sbbEventEntry = (SbbEventEntry) it.next();
			String eventName = sbbEventEntry.getEventName();
			// Dont need an event handler method for FIRED only events.
			if (sbbEventEntry.getEventDirection() == SbbEventEntry.FIRED)
				continue;

			ComponentKey ckey = sbbEventEntry.getEventTypeRefKey();
			EventTypeIDImpl eventTypeID = serviceContainer.getEventManagement()
					.getEventType(ckey);
			// Make sure that the slee knows about this event.
			if (eventTypeID == null) {
				logger.error("event type id " + eventName
						+ " is unknown to the SLEE!");
				return false;
			}
			String methodName = "on" + sbbEventEntry.getEventName();
			MobicentsEventTypeDescriptor eventTypeDesc = serviceContainer
					.getEventManagement().getEventDescriptor(eventTypeID);
			String eventClass = eventTypeDesc.getEventClassName();
			// Check if we have a method of the required name.
			Set methodSet = ClassUtils.getPublicMethods(sbbAbstractClass);
			//methodSet.addAll(ClassUtils.getSuperClassesPublicMethodsFromClass(sbbAbstractClass).values());
			//CtMethod[] methods  = sbbAbstractClass.getMethods();

			CtMethod[] methods = new CtMethod[methodSet.size()];
			methodSet.toArray(methods);

			int i;
			for (i = 0; i < methods.length; i++) {
				if (methods[i].getName().equals(methodName))
					break;
			}

			if (i == methods.length) {
				logger.error("no methods to check against " + methodName);
				return false;
			}
			try {
				if (((CtMethod) methods[i]).getReturnType() != CtClass.voidType) {
					this.errorString = "event handler must have void return type";
					logger.error(errorString);
					return false;
				}
				CtClass[] parameters = ((CtMethod) methods[i])
						.getParameterTypes();
				if (parameters.length != 2) {
					this.errorString = "bad method signature ( wrong number of params!)";
					logger.error(errorString);
					return false;
				}
				CtClass param = parameters[0];

				if (!param.getName().equals(eventClass)) {
					this.errorString = "bad event handler method signature expected "
							+ eventClass;
					logger.error(errorString);
					return false;
				}
				param = parameters[1];

				String customACIName = sbbDeploymentDescriptor
						.getActivityContextInterfaceClassName();
				if (customACIName != null) { // This is a custom SBB activity context interface
					if (!customACIName.equals(param.getName())
							&& !param.getName().equals(
									ActivityContextInterface.class.getName())) {
						this.errorString = "bad event handler method signature expected "
								+ customACIName
								+ " or "
								+ ActivityContextInterface.class.getName();
						logger.error(errorString);
						return false;
					}

				} else if (!param.getName().equals(
						ActivityContextInterface.class.getName())) { // Not a custom ACI
					this.errorString = "bad event handler method signature expected "
							+ ActivityContextInterface.class.getName();
					logger.error(errorString);
					return false;
				}
			} catch (Exception ex) {
				ex.printStackTrace();
			}
			if (sbbEventEntry.isInitial()
					&& sbbEventEntry.getInitialEventSelectorMethod() != null) {
				if (logger.isDebugEnabled()) {
					logger.debug("== CHECKING EVENT SELECTOR METHOD ==");
				}
				String selectorMethodName = sbbEventEntry
						.getInitialEventSelectorMethod();
				//THIS SHOULD LOOK LIKE: methodName(Ljavax/slee/InitialEventSelector;)Ljavax/slee/InitialEventSelector;
				String selectorNameAndSignature = selectorMethodName
						+ "(L"
						+ javax.slee.InitialEventSelector.class.getName()
								.replace('.', '/')
						+ ";)"
						+ "L"
						+ javax.slee.InitialEventSelector.class.getName()
								.replace('.', '/') + ";";
				String selectorForPoeple = "public "
						+ javax.slee.InitialEventSelector.class.getName() + " "
						+ selectorMethodName + "("
						+ javax.slee.InitialEventSelector.class.getName() + ")";
				//8.6.4 Initial event selector method
				//The method signature of the initial event selector method is as follows:
				//public InitialEventSelector
				//<initial event selector method name>(InitialEventSelector ies);
				//· The initial event selector event handler method must be declared as public and cannot be
				//static , abstract, or final.
				//· The method name must not begin with sbb or ejb, and must be a valid Java identifier.
				//· This method is a non-transactional method.
				//· It is only invoked on SBB objects in the Pooled state.
				Map meths = ClassUtils
						.getConcreteMethodsFromClass(sbbAbstractClass);
				CtClass localSbbClass = sbbAbstractClass;
				CtMethod selectorMethod = (CtMethod) meths
						.get(selectorNameAndSignature);

				//LETS CHECK sbb class and super classes until we come up to Object class
				try {
					while (selectorMethod == null
							&& !localSbbClass.getSuperclass().getName().equals(
									Object.class.getName())) {
						localSbbClass = localSbbClass.getSuperclass();
						meths = ClassUtils
								.getConcreteMethodsFromClass(localSbbClass);
						selectorMethod = (CtMethod) meths
								.get(selectorNameAndSignature);
					}
				} catch (NotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				if (selectorMethod == null) {
					this.errorString = "No initial event selector method: "
							+ selectorMethodName + " for "
							+ sbbEventEntry.getEventTypeRefKey()
							+ " expected method signature: "
							+ selectorForPoeple;
					logger.error(errorString);
					return false;
				}

				if (!Modifier.isPublic(selectorMethod.getModifiers())) {
					this.errorString = "Initial event selector method: "
							+ selectorMethodName + " for "
							+ sbbEventEntry.getEventTypeRefKey()
							+ " MUST BE PUBLIC";
					logger.error(errorString);
					return false;
				}

				if (Modifier.isStatic(selectorMethod.getModifiers())) {
					this.errorString = "Initial event selector method: "
							+ selectorMethodName + " for "
							+ sbbEventEntry.getEventTypeRefKey()
							+ " CAN NOT BE STATIC";
					logger.error(errorString);
					return false;
				}
				if (Modifier.isFinal(selectorMethod.getModifiers())) {
					this.errorString = "Initial event selector method: "
							+ selectorMethodName + " for "
							+ sbbEventEntry.getEventTypeRefKey()
							+ " CAN NOT BE FINAL";
					logger.error(errorString);
					return false;
				}

				if (logger.isDebugEnabled()) {
					logger.debug(" == event selector method:"
							+ selectorForPoeple + " has been verified.");
				}

			}
			if (logger.isDebugEnabled()) {
				logger.debug("found an event handler "
						+ ((CtMethod) methods[i]).getName());
			}
		}
		return true;

	}
}
